# ğŸ“˜ LinkedHashMap & TreeMap â€“ Complete Notes (Implementation + Diagrams)

---

## ğŸ”¹ 1. LinkedHashMap

### âœ… What is LinkedHashMap?

LinkedHashMap is an **ordered Map implementation** that maintains **insertion order** or **access order**.

---

### ğŸ§± Data Structures Used

LinkedHashMap internally uses **two data structures together**:

1. **Hash Table (Array of Buckets)** â€“ for fast access
2. **Doubly Linked List** â€“ for maintaining order

```
Hashing  +  Doubly Linked List
```

---

### ğŸ§  Internal Entry Structure

Each entry stores extra pointers for order:

```
Entry
 â”œâ”€â”€ key
 â”œâ”€â”€ value
 â”œâ”€â”€ next    (bucket chain)
 â”œâ”€â”€ before  (previous node in order)
 â””â”€â”€ after   (next node in order)
```

---

### ğŸ“Š Diagram â€“ LinkedHashMap (Insertion Order)

**Operations:**

```
put(10, "A")
put(20, "B")
put(15, "C")
```

**Hash Table (Buckets):**

```
Index 0 -> null
Index 1 -> (10,A)
Index 2 -> (20,B)
Index 3 -> (15,C)
```

**Doubly Linked List (Order Maintained):**

```
HEAD
 â†“
(10,A) â‡„ (20,B) â‡„ (15,C)
 â†‘                     â†“
TAIL <-----------------
```

â¡ï¸ Iteration happens using the **linked list**, not the hash table.

---

### ğŸ” Access Order Mode (LRU Cache)

```
new LinkedHashMap<>(16, 0.75f, true);
```

When an entry is accessed:

```
Before: A â‡„ B â‡„ C
Access B
After:  A â‡„ C â‡„ B
```

---

### â±ï¸ Time Complexity

| Operation | Time |
| --------- | ---- |
| put       | O(1) |
| get       | O(1) |
| iteration | O(n) |

---

### ğŸ¯ Key Notes (Interview)

* Maintains order
* Extra memory due to linked list
* Used in cache / LRU implementations
* Slightly slower than HashMap

---

---

## ğŸ”¹ 2. TreeMap

### ğŸ§  Red-Black Tree Linking â€“ Step by Step (With Arrows)

Below is a **visual explanation** of how `Entry` nodes are linked using **left / right / parent pointers** when inserting keys.

---

### â–¶ Insert keys one by one: `10, 5, 15`

---

### ğŸ”¹ Step 1: Insert 10 (First node)

```
Entry(10)
 â”œâ”€â”€ key   = 10
 â”œâ”€â”€ value = A
 â”œâ”€â”€ left  = null
 â”œâ”€â”€ right = null
 â”œâ”€â”€ parent= null
 â””â”€â”€ color = BLACK   (Root is always BLACK)
```

Tree:

```
   10(B)
```

---

### ğŸ”¹ Step 2: Insert 5

Comparison:

```
5 < 10  â†’ go LEFT
```

Pointers:

```
Entry(5).parent â†’ Entry(10)
Entry(10).left  â†’ Entry(5)
```

Tree:

```
      10(B)
      /
   5(R)
```

(Inserted nodes start as RED)

---

### ğŸ”¹ Step 3: Insert 15

Comparison:

```
15 > 10 â†’ go RIGHT
```

Pointers:

```
Entry(15).parent â†’ Entry(10)
Entry(10).right  â†’ Entry(15)
```

Tree:

```
        10(B)
       /     \
   5(R)     15(R)
```

---

### ğŸ”— How Entry fields are linked (Arrow View)

```
Entry(10)
 â”œâ”€â”€ left  â”€â”€â”€â”€â”€â–¶ Entry(5)
 â”œâ”€â”€ right â”€â”€â”€â”€â–¶ Entry(15)
 â””â”€â”€ parent â”€â”€â”€â–¶ null

Entry(5)
 â”œâ”€â”€ parent â”€â”€â”€â–¶ Entry(10)
 â”œâ”€â”€ left  â”€â”€â”€â”€â–¶ null
 â””â”€â”€ right â”€â”€â”€â–¶ null

Entry(15)
 â”œâ”€â”€ parent â”€â”€â”€â–¶ Entry(10)
 â”œâ”€â”€ left  â”€â”€â”€â”€â–¶ null
 â””â”€â”€ right â”€â”€â”€â–¶ null
```

---

### ğŸ¨ Why Coloring is Needed?

Color rules ensure the tree remains **balanced**:

* Root is always BLACK
* No two RED nodes can be adjacent
* Every path from root to leaf has same number of BLACK nodes

These rules guarantee:

```
Tree height = O(log n)
```

---

### ğŸ§  Meaning of:

```
BST + Coloring Rules â†’ Balanced Tree
```

* **BST** â†’ Left < Root < Right
* **Coloring rules** â†’ Prevent tree from becoming skewed
* Result â†’ Fast search, insert, delete

---

ğŸ“Œ This is exactly how **TreeMap internally stores and links entries**.

---

## ğŸ§ª Full Example â€“ Given Insert Sequence (With Update Case)

### Operations

```
put(10,  "A")
put(20,  "B")
put(151, "C2")
put(101, "A3")
put(201, "B4")
put(151, "C6")  // duplicate key â†’ UPDATE
```

---

### ğŸ”¹ Step 1: put(10, "A")

```
   10(B)
```

Root node â†’ BLACK

---

### ğŸ”¹ Step 2: put(20, "B")

Comparison:

```
20 > 10 â†’ RIGHT
```

Tree:

```
   10(B)
       \
       20(R)
```

---

### ğŸ”¹ Step 3: put(151, "C2")

Comparison:

```
151 > 10 â†’ RIGHT
151 > 20 â†’ RIGHT
```

Before balancing:

```
   10(B)
       \
       20(R)
           \
           151(R)
```

âš ï¸ Redâ€“Red violation â†’ rotation + recolor

After balancing:

```
        20(B)
       /     \
   10(R)   151(R)
```

---

### ğŸ”¹ Step 4: put(101, "A3")

Comparison:

```
101 > 20  â†’ RIGHT
101 < 151 â†’ LEFT
```

Tree:

```
        20(B)
       /     \
   10(B)   151(B)
           /
       101(R)
```

---

### ğŸ”¹ Step 5: put(201, "B4")

Comparison:

```
201 > 20  â†’ RIGHT
201 > 151 â†’ RIGHT
```

Tree:

```
        20(B)
       /     \
   10(B)   151(B)
           /     \
       101(R)   201(R)
```

Tree is balanced âœ”

---

### ğŸ”¹ Step 6: put(151, "C6")  (IMPORTANT)

âš ï¸ **Duplicate key** detected

What happens internally:

```
compare(151, 151) == 0
```

âœ” No new node is created
âœ” Tree structure remains SAME
âœ” Only VALUE is replaced

```
OLD : 151 â†’ "C2"
NEW : 151 â†’ "C6"
```

Final Tree Structure:

```
        20(B)
       /     \
   10(B)   151(B)
           /     \
       101(R)   201(R)
```

---

### ğŸ”— Pointer View (Entry Linking)

```
Entry(151)
 â”œâ”€â”€ key    = 151
 â”œâ”€â”€ value  = "C6"   // updated
 â”œâ”€â”€ parent â†’ Entry(20)
 â”œâ”€â”€ left   â†’ Entry(101)
 â””â”€â”€ right  â†’ Entry(201)
```

---

### ğŸ§  Key Takeaways (INTERVIEW GOLD)

* TreeMap **never allows duplicate keys**
* Duplicate `put()` â†’ **value update only**
* Structure changes **only if key is new**
* Sorting is always by **key**, never value

---

### ğŸ¯ One-liner

> TreeMap uses a Red-Black Tree; duplicate keys update values without affecting structure.

---

---

### âœ… What is TreeMap?

TreeMap is a **sorted Map implementation** that keeps keys in **ascending order** (or custom order).

---

### ğŸ§± Data Structure Used

### â­ Red-Black Tree (Self-balancing Binary Search Tree)

```
BST + Coloring Rules â†’ Balanced Tree
```

---

### ğŸ§  Internal Node Structure

```
Entry
 â”œâ”€â”€ key
 â”œâ”€â”€ value
 â”œâ”€â”€ left
 â”œâ”€â”€ right
 â”œâ”€â”€ parent
 â””â”€â”€ color (RED / BLACK)
```

---

### ğŸŒ³ Diagram â€“ TreeMap (Natural Order)

**Operations:**

```
put(10, "A")
put(20, "B")
put(15, "C")
```

**Red-Black Tree Structure:**

```
        15 (BLACK)
       /          \
   10 (RED)     20 (RED)
```

âœ” Tree remains balanced automatically.

---

### ğŸ”„ Sorting Mechanism

Keys are compared using:

* `Comparable` OR
* `Comparator`

```
compare(k1, k2)
```

Left â†’ smaller key
Right â†’ larger key

---

### ğŸ” Iteration Order

TreeMap uses **IN-ORDER traversal**:

```
Left â†’ Root â†’ Right
```

Output order:

```
10 â†’ 15 â†’ 20
```

---

### â±ï¸ Time Complexity

| Operation | Time     |
| --------- | -------- |
| put       | O(log n) |
| get       | O(log n) |
| remove    | O(log n) |

---

### âš ï¸ TreeMap Rules

* âŒ Null keys not allowed
* âœ… Null values allowed
* Keys must be comparable

---

---

## ğŸ”¥ LinkedHashMap vs TreeMap (Quick Revision)

| Feature         | LinkedHashMap      | TreeMap        |
| --------------- | ------------------ | -------------- |
| Order           | Insertion / Access | Sorted         |
| Data Structure  | HashTable + DLL    | Red-Black Tree |
| Time Complexity | O(1)               | O(log n)       |
| Null Key        | 1 allowed          | âŒ              |
| Use Case        | Cache, Order       | Sorted Data    |

---

## ğŸ§  Memory Trick

```
HashMap        â†’ No order
LinkedHashMap â†’ Order
TreeMap       â†’ Sorted
```

---

## ğŸ¯ Interview One-Liners

* **LinkedHashMap:** Maintains order using a doubly linked list on top of HashMap.
* **TreeMap:** Maintains sorted keys using a Red-Black Tree.

---

âœ… End of Notes
