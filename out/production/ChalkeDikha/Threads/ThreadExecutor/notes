# ThreadPoolExecutor ‚Äî Complete & Deep-Dive Notes (Interview + Practical)

---

## 1Ô∏è‚É£ What is a Thread Pool?

A **Thread Pool** is a managed collection of reusable worker threads that execute submitted tasks.

Instead of:

* Creating a new thread for every task ‚ùå

We:

* Create a fixed/controlled number of threads once
* Reuse them to execute many tasks ‚úÖ

This is implemented in Java using the **Executor Framework** (`java.util.concurrent`).

---

## 2Ô∏è‚É£ Why Thread Pool is Needed?

### ‚ùå Problems without Thread Pool

* Thread creation is expensive (stack, PC, registers)
* Uncontrolled thread creation ‚Üí **CPU context switching**
* Hard to manage thread lifecycle (start, stop, wait)
* Risk of **OutOfMemoryError**

### ‚úÖ Benefits of Thread Pool

1. **Thread Reuse** ‚Üí saves creation cost
2. **Controlled Concurrency** ‚Üí avoids CPU thrashing
3. **Better Performance** ‚Üí less context switching
4. **Lifecycle Management** ‚Üí framework handles it
5. **Backpressure Support** ‚Üí via queues

---

## 3Ô∏è‚É£ Executor Framework Hierarchy

```
Executor (interface)
   |
   ‚îî‚îÄ‚îÄ ExecutorService (interface)
         |
         ‚îú‚îÄ‚îÄ ThreadPoolExecutor (class)
         ‚îú‚îÄ‚îÄ ScheduledThreadPoolExecutor
         ‚îî‚îÄ‚îÄ ForkJoinPool
```

* `Executor` ‚Üí only `execute()`
* `ExecutorService` ‚Üí lifecycle (`shutdown`, `submit`)
* `ThreadPoolExecutor` ‚Üí **fully configurable thread pool**

---

## 4Ô∏è‚É£ ThreadPoolExecutor Constructor (MOST IMPORTANT)

```java
ThreadPoolExecutor(
  int corePoolSize,
  int maximumPoolSize,
  long keepAliveTime,
  TimeUnit unit,
  BlockingQueue<Runnable> workQueue,
  ThreadFactory threadFactory,
  RejectedExecutionHandler handler
)
```

Each parameter matters. Let‚Äôs break them.

---

## 5Ô∏è‚É£ corePoolSize (Minimum Threads)

* Minimum number of threads kept alive in the pool
* Created eagerly or lazily
* Even if idle ‚Üí **NOT destroyed** (by default)

### Example

```java
corePoolSize = 2
```

‚û° Pool always keeps **2 threads alive**

---

## 6Ô∏è‚É£ maximumPoolSize (Upper Limit)

* Maximum threads allowed in pool
* Extra threads created **only when**:

  * core threads busy
  * queue is full

### Example

```java
maximumPoolSize = 4
```

‚û° Pool can grow from 2 ‚Üí 4 under load

---

## 7Ô∏è‚É£ Task Submission Flow (VERY IMPORTANT)

When a task is submitted:

```
1Ô∏è‚É£ If active threads < corePoolSize
   ‚Üí create new thread

2Ô∏è‚É£ Else try to enqueue task

3Ô∏è‚É£ If queue full AND threads < maxPoolSize
   ‚Üí create new thread

4Ô∏è‚É£ Else
   ‚Üí reject task
```

This explains WHY queue is checked before max threads.

---

## 8Ô∏è‚É£ workQueue (Task Buffer)

Holds tasks waiting for execution.

### Types

| Queue               | Bounded | Behavior                      |
| ------------------- | ------- | ----------------------------- |
| ArrayBlockingQueue  | ‚úÖ       | Fixed capacity (recommended)  |
| LinkedBlockingQueue | ‚ùå       | Can grow indefinitely (risky) |
| SynchronousQueue    | ‚ùå       | No storage (direct handoff)   |

‚ö†Ô∏è **Bounded queues are preferred**

---

## 9Ô∏è‚É£ keepAliveTime + allowCoreThreadTimeOut

### keepAliveTime

* Time an **idle thread** waits before termination

### allowCoreThreadTimeOut

* Default: `false`
* If `true`, even core threads can die after idle time

```java
executor.allowCoreThreadTimeOut(true);
```

---

## üîü ThreadFactory

Controls **how threads are created**

Can set:

* Thread name
* Priority
* Daemon flag

### Example

```java
ThreadFactory factory = r -> {
    Thread t = new Thread(r);
    t.setName("worker-" + t.getId());
    t.setPriority(Thread.NORM_PRIORITY);
    return t;
};
```

---

## 1Ô∏è‚É£1Ô∏è‚É£ RejectedExecutionHandler

Handles tasks when:

* Queue is full
* Pool reached max size

### Built-in Policies

| Policy              | Behavior             |
| ------------------- | -------------------- |
| AbortPolicy         | Throw exception ‚ùå    |
| DiscardPolicy       | Silently drop ‚ùå      |
| CallerRunsPolicy    | Run in caller thread |
| DiscardOldestPolicy | Drop oldest task     |

### Custom Handler

```java
RejectedExecutionHandler handler = (task, executor) ->
    System.out.println("Task rejected: " + task);
```

---

## 1Ô∏è‚É£2Ô∏è‚É£ ThreadPool Lifecycle

### States

| State      | Meaning                       |
| ---------- | ----------------------------- |
| RUNNING    | Accept + execute tasks        |
| SHUTDOWN   | No new tasks, finish existing |
| STOP       | Stop immediately              |
| TERMINATED | All threads stopped           |

### Methods

```java
shutdown();      // graceful
shutdownNow();   // force
isTerminated();
```

---

## 1Ô∏è‚É£3Ô∏è‚É£ COMPLETE WORKING CODE EXAMPLE

```java
import java.util.concurrent.*;

public class ThreadPoolDemo {
    public static void main(String[] args) {

        ThreadPoolExecutor executor = new ThreadPoolExecutor(
                2,
                4,
                10,
                TimeUnit.SECONDS,
                new ArrayBlockingQueue<>(2),
                r -> {
                    Thread t = new Thread(r);
                    t.setName("worker-" + t.getId());
                    return t;
                },
                (r, ex) -> System.out.println("Task rejected: " + r)
        );

        for (int i = 1; i <= 7; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("Task " + taskId + " executed by " + Thread.currentThread().getName());
                try { Thread.sleep(5000); } catch (InterruptedException e) {}
            });
        }

        executor.shutdown();
    }
}
```

---

## 1Ô∏è‚É£4Ô∏è‚É£ Expected Output (Order may vary)

```
Task 1 executed by worker-12
Task 2 executed by worker-13
Task 3 executed by worker-12
Task 4 executed by worker-13
Task 5 executed by worker-14
Task 6 executed by worker-15
Task rejected
```

---

## 1Ô∏è‚É£5Ô∏è‚É£ Interview Question: Why corePoolSize = 2?

### Factors to Consider

1Ô∏è‚É£ CPU Cores

* CPU-bound ‚Üí threads ‚âà cores
* IO-bound ‚Üí threads > cores

2Ô∏è‚É£ Task Nature

* CPU intensive ‚Üí fewer threads
* IO intensive ‚Üí more threads

3Ô∏è‚É£ JVM Memory

* Each thread needs stack + heap

4Ô∏è‚É£ Heap per Request

* Memory per task limits concurrency

---

## 1Ô∏è‚É£6Ô∏è‚É£ Thumb Rule Formula

```
Threads ‚âà CPU cores √ó (1 + wait_time / compute_time)
```

‚ö†Ô∏è Not final ‚Äî must validate with:

* Load testing
* Monitoring

---

üëâ corePoolSize = MINIMUM threads

Always alive

Baseline capacity

üëâ maxPoolSize = MAXIMUM threads

Upper limit

Used only during spikes

This never changes.

‚úÖ Now, HOW to decide the numbers (CLEAR FLOW)
STEP 1Ô∏è‚É£ ‚Äî Find CPU cores (starting point)
int cpu = Runtime.getRuntime().availableProcessors();


Example:

cpu = 8


This number is your reference, not the final answer.

STEP 2Ô∏è‚É£ ‚Äî Identify task type (MOST IMPORTANT)

Ask one question:

‚ÄúDoes my thread mostly COMPUTE or mostly WAIT?‚Äù

A) CPU-BOUND (mostly compute)

Examples:

calculations

JSON parsing

encryption

analytics

‚û° Thread is busy using CPU

B) I/O-BOUND (mostly waiting)

Examples:

DB calls

REST calls

file read/write

‚û° Thread spends time waiting, not using CPU

üéØ NOW THE ACTUAL NUMBERS (MIN & MAX)
üîπ Case 1: CPU-BOUND tasks
‚úÖ Minimum (corePoolSize)
corePoolSize = CPU cores


Why?

You don‚Äôt want more active threads than CPU cores

Example:

cpu = 8
corePoolSize = 8   ‚úÖ MIN

‚úÖ Maximum (maxPoolSize)
maxPoolSize = corePoolSize + 1


Why?

Allows tiny flexibility

Avoids context switching

Example:

maxPoolSize = 9   ‚úÖ MAX

‚ùå What NOT to do
core = 20
max = 50


This will slow the system.

üîπ Case 2: I/O-BOUND tasks (MOST REAL SYSTEMS)
‚úÖ Minimum (corePoolSize)
corePoolSize = 2 √ó CPU cores


Why?

Threads wait on I/O

More threads keep CPU busy

Example:

cpu = 8
corePoolSize = 16   ‚úÖ MIN

‚úÖ Maximum (maxPoolSize)
maxPoolSize = 2‚Äì4 √ó CPU cores


Why?

Handles traffic spikes

Prevents queue overflow

Example:

maxPoolSize = 32   ‚úÖ MAX

‚ùå Why NOT choose random numbers (10, 20, 100)?

Because:

Each thread uses memory

Too many threads ‚Üí context switching

Throughput drops

Latency increases

üìå Why examples use (2, 4)?

This is ONLY for learning, not real systems.

core = 2
max  = 4
queue = 2


So you can SEE:

core threads

queue filling

max threads

rejection

üß† Ultra-simple table (REMEMBER THIS)
Task type	MIN (corePoolSize)	MAX (maxPoolSize)
CPU-bound	CPU cores	CPU + 1
I/O-bound	2 √ó CPU	2‚Äì4 √ó CPU
üéØ Final interviewer answer (clean & confident)

‚ÄúcorePoolSize is the minimum number of threads kept alive for steady load,
and maxPoolSize is the maximum allowed during spikes.
Both are chosen based on CPU cores and whether the task is CPU-bound or I/O-bound.‚Äù

7Ô∏è‚É£ Golden rule (optional mention)
Threads = CPU √ó (1 + waitTime / computeTime)

One-line interview answer

‚ÄúThread pool sizes are chosen based on CPU cores and whether the task is
 CPU-bound or I/O-bound. Core threads handle steady load, max threads handle
  spikes, and oversizing causes performance issues.‚Äù
