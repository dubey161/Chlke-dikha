# Java Map & HashMap â€“ Complete Notes (Interview + Internals)

---

## 1ï¸âƒ£ Why `Map` is **NOT** part of `Collection`

```
Collection  â†’ works with single values
Map         â†’ works with keyâ€“value pairs
```

* `List`, `Set`, `Queue` â†’ store **values only**
* `Map` â†’ stores **key â†’ value mapping**
* Hence Map needs **different APIs** (`put`, `get`, `entrySet`) and is **not a child of Collection**

---

## 2ï¸âƒ£ Map Basics

```java
Map<Integer, String> map = new HashMap<>();
```

### Properties

* Keys âŒ cannot be duplicate
* Values âœ… can be duplicate
* Duplicate key â†’ **value overwritten**

```java
map.put(1, "A");
map.put(1, "B"); // overwrites A
```

---

## 3ï¸âƒ£ Map Implementations

```
Map (interface)
 â”œâ”€â”€ HashMap
 â”œâ”€â”€ LinkedHashMap
 â”œâ”€â”€ TreeMap
 â”œâ”€â”€ Hashtable (legacy)
 â””â”€â”€ ConcurrentHashMap
```

---

## 4ï¸âƒ£ Important Map Methods

```java
map.size();
map.isEmpty();
map.containsKey(key);
map.get(key);
map.put(key, value);
map.putIfAbsent(key, value);
map.remove(key);
map.getOrDefault(key, defaultValue);
map.keySet();
map.values();
map.entrySet();
```

---

## 5ï¸âƒ£ HashMap Internals (VERY IMPORTANT)

### Internal Data Structure

```
HashMap
 â””â”€â”€ Node<K,V>[] table   // array

Node {
  int hash;
  K key;
  V value;
  Node next;
}
```

So internally:

```
index 0 â†’ Node â†’ Node â†’ Node
index 1 â†’ null
index 2 â†’ Node
```

---

## 6ï¸âƒ£ Default Values

| Property         | Value                        |
| ---------------- | ---------------------------- |
| Initial capacity | 16                           |
| Load factor      | 0.75                         |
| Resize condition | size > capacity Ã— loadFactor |

---

## 7ï¸âƒ£ How `put()` Works (Step-by-Step)

```java
map.put(10, "A");
```

### Steps:

1. `hash = hash(key)`
2. `index = hash % table.length`
3. If bucket empty â†’ insert
4. If bucket occupied:

   * same key â†’ overwrite
   * different key â†’ **collision** â†’ chaining

### Collision Handling

```
index 1 â†’ (1,A) â†’ (10,B) â†’ (5,C)
```

This is **linked list chaining**.

---

## 8ï¸âƒ£ How `get()` Works

```java
map.get(5);
```

1. Compute hash of key
2. Find index
3. Traverse linked list / tree
4. Use `equals()` to compare keys

---

## 9ï¸âƒ£ hashCode() & equals() Contract â­

### Rule 1

```
if obj1.equals(obj2) â†’ obj1.hashCode() == obj2.hashCode()
```

### Rule 2

```
if hashCodes same â†’ objects MAY or MAY NOT be equal
```

Why important?

* Hash â†’ find bucket
* equals â†’ find exact key

---

## ğŸ”Ÿ Load Factor & Rehashing

### Example

```
capacity = 16
loadFactor = 0.75
threshold = 12
```

* When 13th entry inserted â†’ **rehash**
* Capacity doubles â†’ 32
* All keys rehashed

Purpose:

* Reduce collisions
* Maintain O(1) average time

---

## 1ï¸âƒ£1ï¸âƒ£ Treeification (Java 8+)

If collisions increase too much:

| Condition       | Action         |
| --------------- | -------------- |
| bucket size < 8 | LinkedList     |
| bucket size â‰¥ 8 | Red-Black Tree |

Result:

```
Worst case = O(log N)
```

---

## 1ï¸âƒ£2ï¸âƒ£ Time Complexity

| Operation | Average | Worst    |
| --------- | ------- | -------- |
| put       | O(1)    | O(log N) |
| get       | O(1)    | O(log N) |
| remove    | O(1)    | O(log N) |

---

## 1ï¸âƒ£3ï¸âƒ£ Null Handling

```java
HashMap<String, String> map = new HashMap<>();
map.put(null, "A");
map.put("B", null);
```

âœ” HashMap allows **one null key**
âœ” Multiple null values

âŒ Hashtable / ConcurrentHashMap â†’ NO nulls

---

## 1ï¸âƒ£4ï¸âƒ£ putIfAbsent Example

```java
map.put(1, null);
map.putIfAbsent(1, "A"); // replaces null
map.putIfAbsent(1, "B"); // ignored
```

---

## 1ï¸âƒ£5ï¸âƒ£ Iterating HashMap

### entrySet (BEST)

```java
for (Map.Entry<Integer, String> e : map.entrySet()) {
    System.out.println(e.getKey() + "=" + e.getValue());
}
```

### keySet

```java
for (Integer k : map.keySet()) {
    System.out.println(k);
}
```

### values

```java
for (String v : map.values()) {
    System.out.println(v);
}
```

---

## 1ï¸âƒ£6ï¸âƒ£ Thread Safety Comparison

| Map               | Thread Safe | Nulls |
| ----------------- | ----------- | ----- |
| HashMap           | âŒ           | âœ”     |
| Hashtable         | âœ”           | âŒ     |
| ConcurrentHashMap | âœ”           | âŒ     |

---

## 1ï¸âƒ£7ï¸âƒ£ HashMap vs ConcurrentHashMap

| Feature     | HashMap       | ConcurrentHashMap |
| ----------- | ------------- | ----------------- |
| Thread safe | âŒ             | âœ”                 |
| Locking     | None          | Bucket-level      |
| Performance | Fast (single) | Fast (multi)      |
| Iterator    | Fail-fast     | Weakly consistent |

---

## 1ï¸âƒ£8ï¸âƒ£ Relation with Set â­

```
HashSet       â†’ uses HashMap
LinkedHashSet â†’ uses LinkedHashMap
TreeSet      â†’ uses TreeMap
```

```java
HashSet<E> internally = new HashMap<E, Object>();
```

Set stores elements as **keys**, dummy object as value.

---

## 1ï¸âƒ£9ï¸âƒ£ Interview One-Liners

* HashMap average complexity â†’ **O(1)**
* Worst case â†’ **O(log N)** (Java 8+)
* Load factor controls resizing
* Treeification prevents long chains
* HashMap not thread-safe

---

## 2ï¸âƒ£0ï¸âƒ£ MUST PRACTICE

* Override `hashCode()` & `equals()`
* Collision examples
* Resize scenario
* ConcurrentHashMap usage

---
| Feature     | HashMap | Hashtable | ConcurrentHashMap |
| ----------- | ------- | --------- | ----------------- |
| Thread-safe | âŒ       | âœ…         | âœ…                 |
| Null key    | âœ… (1)   | âŒ         | âŒ                 |
| Null value  | âœ…       | âŒ         | âŒ                 |
| Performance | â­â­â­     | â­         | â­â­â­â­              |
| Locking     | None    | Full      | Segment/Bucket    |
| Legacy      | âŒ       | âœ…         | âŒ                 |
| Recommended | âœ…       | âŒ         | âœ…                 |





