1Ô∏è‚É£ MULTIPLE PRODUCERS + MULTIPLE CONSUMERS
Case:

3 Producers

3 Consumers

Buffer size = 1

wait/notify behavior ‚ùå

Producer wakes another producer

Consumer wakes another consumer

Threads wake ‚Üí check condition ‚Üí go back to wait

CPU wasted

Context switching explosion

You WILL NOT SEE THIS IN OUTPUT
but JVM is suffering internally.

This is called:

‚ùå Thundering Herd Problem

Lock + Condition behavior ‚úÖ

Producer signals ONLY consumers

Consumer signals ONLY producers

No wrong wakeups

No wasted CPU

üëâ This is the REAL BENEFIT

2Ô∏è‚É£ ONE WAIT-SET vs MULTIPLE WAIT-SETS (KEY DIFFERENCE)
wait/notify
ONE wait queue per object


All threads wait together.

Lock + Condition
Multiple wait queues


Example:

notFull  ‚Üí producers only
notEmpty ‚Üí consumers only


This is IMPOSSIBLE with wait/notify.

3Ô∏è‚É£ SCALING TEST (YOU DID NOT TRY THIS YET)

Try this change üëá
(then difference becomes obvious)

for (int i = 0; i < 3; i++) {
    new Thread(new Producer(buffer)).start();
    new Thread(new Consumer(buffer)).start();
}


Now observe:

wait/notify ‚Üí heavy CPU usage, random wakeups

lock/condition ‚Üí smooth execution

4Ô∏è‚É£ FAIRNESS & CONTROL (IMPOSSIBLE WITH synchronized)

Lock gives:

tryLock()

timeout

fairness

interruptible waiting

wait/notify gives:

‚ùå none of the above

üß† VERY IMPORTANT REALIZATION (PLEASE READ)

Correctness ‚â† Performance

Your example shows correctness
Locks are about performance + scalability

üîë WHY JAVA DID NOT REMOVE wait/notify?

Because:

Simple cases

Teaching

Backward compatibility

But modern Java concurrency uses Locks internally
(ConcurrentHashMap, ThreadPoolExecutor, etc.)

üß† FINAL ANSWER TO YOUR QUESTION
‚ùì ‚ÄúBoth outputs are same, where is benefit?‚Äù
‚úÖ FINAL ANSWER:

The benefit of Lock is NOT visible in small examples.
It becomes critical when you have multiple threads, multiple conditions, and high contention.

üß† ONE-LINE INTERVIEW ANSWER (MEMORIZE)

wait/notify works for simple cases, but Lock + Condition scales correctly under concurrency.