1ï¸âƒ£ What is Stream?

Stream is a lazy pipeline used to process data from a collection/array using functional operations.

Important Points

Stream does NOT store data

Stream does NOT modify original collection

Stream works only when terminal operation is called

Stream can be used only once


2ï¸âƒ£ Stream Pipeline

SOURCE â†’ INTERMEDIATE OPERATIONS â†’ TERMINAL OPERATION


list.stream()        // Source
    .filter(...)     // Intermediate
    .map(...)        // Intermediate
    .forEach(...);   // Terminal


âš ï¸ Without terminal operation â†’ NOTHING EXECUTES

3ï¸âƒ£ Lazy Streaming (MOST IMPORTANT)
What is Lazy Streaming?

Intermediate operations are not executed immediately.
They execute only when terminal operation is called.

Example (LAZY â€“ NOTHING PRINTS)

List<Integer> list = List.of(1, 2, 3, 4);

list.stream()
    .filter(n -> {
        System.out.println("Filter: " + n);
        return n > 2;
    });

âŒ Because no terminal operation

list.stream()
    .filter(n -> {
        System.out.println("Filter: " + n);
        return n > 2;
    })
    .count();

OUTPUT:
Filter: 1
Filter: 2
Filter: 3
Filter: 4


4ï¸âƒ£ filter() â€“ Predicate

Filters elements based on condition.

list.stream()
    .filter(n -> {
        System.out.println("Checking: " + n);
        return n % 2 == 0;
    })
    .forEach(System.out::println);

Checking: 1
Checking: 2
2
Checking: 3
Checking: 4
4

5ï¸âƒ£ map() â€“ Transformation

Transforms each element.

list.stream()
    .map(n -> {
        System.out.println("Mapping: " + n);
        return n * 10;
    })
    .forEach(System.out::println);


Mapping: 1
10
Mapping: 2
20
Mapping: 3
30
Mapping: 4
40

6ï¸âƒ£ filter + map (Execution Order)

Streams work element by element, not operation by operation.

list.stream()
    .filter(n -> {
        System.out.println("Filter: " + n);
        return n > 2;
    })
    .map(n -> {
        System.out.println("Map: " + n);
        return n * 2;
    })
    .forEach(System.out::println);


7ï¸âƒ£ flatMap() â€“ Flattening
map() âŒ (Gives Stream<Stream>)

List<List<Integer>> lists = List.of(
    List.of(1, 2),
    List.of(3, 4)
);

lists.stream()
     .map(l -> l.stream())
     .forEach(System.out::println);


OUTPUT:
java.util.stream.ReferencePipeline$Head@xxxx
java.util.stream.ReferencePipeline$Head@xxxx


lists.stream()
     .flatMap(l -> l.stream())
     .forEach(System.out::println);
o/p
1
2
3
4

8ï¸âƒ£ distinct() â€“ Remove Duplicates

List<Integer> nums = List.of(1, 2, 2, 3, 3);
nums.stream()
    .distinct()
    .forEach(System.out::println);

    OUTPUT:
    1
    2
    3
âš ï¸ Uses equals() and hashCode()

    9ï¸âƒ£ sorted()
    nums.stream()
        .sorted()
        .forEach(System.out::println);


OUTPUT:
1
2
2
3
3

Reverse Order
.sorted((a, b) -> b - a)

ğŸ”Ÿ limit() & skip()

list.stream()
    .limit(2)
    .forEach(System.out::println);

    OUTPUT:
    1
    2

    list.stream()
        .skip(2)
        .forEach(System.out::println);

    OUTPUT:
    3
    4

1ï¸âƒ£1ï¸âƒ£ peek() â€“ Debugging ONLY

list.stream()
    .peek(n -> System.out.println("Peek: " + n))
    .filter(n -> n > 2)
    .forEach(System.out::println);


Peek: 1
Peek: 2
Peek: 3
3
Peek: 4
4


1ï¸âƒ£2ï¸âƒ£ Terminal Operations

forEach()
list.stream().forEach(System.out::println);

collect()
List<Integer> newList =
    list.stream().collect(Collectors.toList());

ğŸ”¹ reduce() â€“ Aggregation
âœ… Definition

reduce() is a terminal operation used to combine all elements of a stream into a single value using an accumulator function.

ğŸ‘‰ It repeatedly applies the operation:

result = result âŠ• element

Code
List<Integer> list = List.of(1, 2, 3, 4);

int sum = list.stream()
              .reduce(0, (a, b) -> a + b);

System.out.println(sum);

OUTPUT
10

Notes

0 â†’ identity (starting value)

(a, b) â†’ accumulator

Common uses: sum, multiplication, max, min

Stream becomes closed after reduce


ğŸ”¹ count()
âœ… Definition

count() is a terminal operation that returns the number of elements present in the stream.

Code
long c = list.stream().count();
System.out.println(c);

OUTPUT
4

Notes

Return type is long

Triggers lazy execution

Stream cannot be reused after this

ğŸ”¹ findFirst()
âœ… Definition

findFirst() returns the first element of the stream wrapped inside an Optional.

Code
System.out.println(list.stream().findFirst().get());

OUTPUT
1


Notes

Returns Optional<T>

.get() used only when sure value exists

Maintains encounter order

Safer version: orElse()


ğŸ”¹ anyMatch()
âœ… Definition

anyMatch() checks if at least one element in the stream matches the given condition.

Code
System.out.println(list.stream().anyMatch(n -> n > 3));

OUTPUT
true

Notes

Short-circuit operation

Stops once condition is satisfied

ğŸ”¹ allMatch()
âœ… Definition

allMatch() checks if all elements in the stream satisfy the condition.

Code
System.out.println(list.stream().allMatch(n -> n > 0));

OUTPUT
true

ğŸ”¹ noneMatch()
âœ… Definition

noneMatch() checks if no elements in the stream match the condition.

Code
System.out.println(list.stream().noneMatch(n -> n < 0));

OUTPUT
true


1ï¸âƒ£3ï¸âƒ£ Stream Reuse âŒ NOT ALLOWED
âœ… Rule

A stream can be consumed only once.
After a terminal operation, the stream is closed permanently.

Code
Stream<Integer> s = list.stream();

s.forEach(System.out::println); // terminal operation
s.count(); // âŒ ERROR

OUTPUT
1
2
3
4
Exception in thread "main" java.lang.IllegalStateException: stream has already been operated upon or closed

Notes

Always create a new stream

Streams are NOT reusable like collections

1ï¸âƒ£4ï¸âƒ£ Parallel Stream
âœ… Definition

parallelStream() splits data into multiple parts and processes them concurrently using multiple CPU cores.

Code
list.parallelStream()
    .forEach(System.out::println);

OUTPUT (Example)
3
1
4
2


âš ï¸ Output order is NOT guaranteed

Important Parallel Stream Notes



ğŸ“˜ Java Streams: Stream<Integer> vs int[] vs IntStream
1ï¸âƒ£ Stream<Integer> (Object Stream)
âœ… Definition

Stream<Integer> is a stream of wrapper objects (Integer).
It is used when working with Collections or when null values are needed.

ğŸ“¥ Input
List<Integer> list = List.of(1, 2, 3, 4);

ğŸ’» Code
list.stream()
    .map(n -> n * 2)
    .forEach(System.out::println);

ğŸ–¨ OUTPUT
2
4
6
8

ğŸ§  Notes

Uses boxing/unboxing

Supports null

Slightly slower than primitive streams

Common with List, Set, Map

2ï¸âƒ£ int[] â†’ Stream
âœ… Definition

Arrays of primitives (int[]) are NOT collections, but can be converted to a stream using Arrays.stream().

ğŸ“¥ Input
int[] arr = {1, 2, 3, 4};

ğŸ’» Code
Arrays.stream(arr)
      .forEach(System.out::println);

ğŸ–¨ OUTPUT
1
2
3
4

ğŸ§  Notes

Arrays.stream(int[]) returns IntStream

No boxing overhead

Faster than Stream<Integer>

3ï¸âƒ£ IntStream (Primitive Stream)
âœ… Definition

IntStream is a primitive stream designed specifically for int values.
It avoids boxing/unboxing overhead and provides numeric operations.

ğŸ“¥ Input
IntStream intStream = IntStream.of(1, 2, 3, 4);

ğŸ’» Code
IntStream.of(1, 2, 3, 4)
         .map(n -> n * 2)
         .forEach(System.out::println);

ğŸ–¨ OUTPUT
2
4
6
8

ğŸ§  Notes

No boxing/unboxing

Faster & memory efficient

Provides numeric methods like sum(), average()

4ï¸âƒ£ Converting Stream<Integer> â†’ IntStream
ğŸ’» Code
list.stream()
    .mapToInt(Integer::intValue)
    .forEach(System.out::println);

ğŸ–¨ OUTPUT
1
2
3
4

ğŸ§  Notes

mapToInt() converts object stream to primitive stream

Required for numeric terminal ops like sum()

5ï¸âƒ£ Converting IntStream â†’ Stream<Integer>
ğŸ’» Code
IntStream.of(1, 2, 3)
         .boxed()
         .forEach(System.out::println);

ğŸ–¨ OUTPUT
1
2
3

ğŸ§  Notes

boxed() converts primitive to wrapper

Needed when collecting into List<Integer>

6ï¸âƒ£ Numeric Terminal Operations (ONLY in Primitive Streams)
ğŸ’» Code
int sum = IntStream.of(1, 2, 3, 4).sum();
System.out.println(sum);

ğŸ–¨ OUTPUT
10

ğŸ’» Average
System.out.println(IntStream.of(1, 2, 3, 4).average().getAsDouble());

OUTPUT
2.5

7ï¸âƒ£ Stream Creation Comparison
Source	Stream Type
List<Integer>	Stream<Integer>
int[]	IntStream
Stream.of(1,2)	Stream<Integer>
IntStream.of(1,2)	IntStream
8ï¸âƒ£ When to Use What?
âœ… Use Stream<Integer> when:

Working with collections

Need null

Object-based operations

âœ… Use IntStream when:

Heavy numeric processing

Performance matters

Sum, average, max, min required

ğŸ”¥ One-Line Interview Answer

Stream<Integer> uses boxed integers, while IntStream is a primitive stream without boxing and is faster for numeric operations.

Uses ForkJoinPool

Uses multiple threads

Faster for large data

âŒ Avoid shared mutable variables

âŒ Avoid order-dependent logic

ğŸ”¥ FINAL QUICK REVISION

reduce() â†’ combine to single value

count() â†’ total elements

findFirst() â†’ first element

anyMatch() â†’ at least one match

allMatch() â†’ all must match

noneMatch() â†’ no match It returns true only if zero elements match the predicate.

Stream reuse â†’ âŒ NOT allowed

parallelStream â†’ unordered, multi-threaded


ğŸ”¹ What is mapToInt()?
âœ… Definition

mapToInt() is an intermediate operation that converts an object stream (Stream<T>) into a primitive IntStream.

It is mainly used for:

Converting wrapper/object values to primitive int

Enabling numeric operations like sum(), average()

ğŸ“¥ Input (Strings)
List<String> list = List.of("10", "20", "30");

ğŸ’» Code â€“ Convert String â†’ int
list.stream()
    .mapToInt(Integer::parseInt)
    .forEach(System.out::println);

ğŸ–¨ OUTPUT
10
20
30


ğŸ”¹ Lazy Execution Proof
list.stream()
    .mapToInt(s -> {
        System.out.println("Converting: " + s);
        return Integer.parseInt(s);
    });

OUTPUT
(no output â€“ no terminal operation)

Now with Terminal Operation
list.stream()
    .mapToInt(s -> {
        System.out.println("Converting: " + s);
        return Integer.parseInt(s);
    })
    .sum();

OUTPUT
Converting: 10
Converting: 20
Converting: 30

ğŸ”¥ Difference:
map(Integer::parseInt).reduce(...)
vs
mapToInt(Integer::parseInt).sum()

âœ… Both DO the SAME thing

âœ”ï¸ Convert String â†’ int
âœ”ï¸ Sum all elements
âœ”ï¸ Return int
âœ”ï¸ Same output

List<String> list = List.of("10", "20", "30");

1ï¸âƒ£ Using map() + reduce()
int sum = list.stream()
              .map(Integer::parseInt)
              .reduce(0, Integer::sum);

What happens internally

"10" â†’ Integer(10) â† BOXING

"20" â†’ Integer(20)

reduce() â†’ UNBOX â†’ add â†’ BOX again

Characteristics
Point	Value
Stream type	Stream<Integer>
Boxing	âœ… YES
Performance	Slower
Memory	More
Flexibility	Very high
2ï¸âƒ£ Using mapToInt() + sum()
int sum = list.stream()
              .mapToInt(Integer::parseInt)
              .sum();

What happens internally

"10" â†’ int 10

"20" â†’ int 20

sum() â†’ direct primitive addition

Characteristics
Point	Value
Stream type	IntStream
Boxing	âŒ NO
Performance	Faster
Memory	Less
Numeric ops	Built-in (sum, avg)
ğŸ”¥ KEY DIFFERENCE (ONE LINE)

map() creates wrapper objects (Integer), while mapToInt() works on primitive int and avoids boxing/unboxing.

âš ï¸ Performance Visual (IMPORTANT)
map() + reduce()
"10" â†’ Integer(10) â†’ unbox â†’ add â†’ box â†’ result

mapToInt() + sum()
"10" â†’ int 10 â†’ add â†’ result

